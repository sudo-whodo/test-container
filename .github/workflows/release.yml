name: Release

on:
  pull_request:
    types: [ closed ]
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_release:
        description: 'Force create a release even if no changes detected'
        required: false
        default: false
        type: boolean
      release_type:
        description: 'Type of release to create'
        required: false
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major

env:
  CONTAINER_NAME: test-api-release-container
  IMAGE_NAME: test-api
  PORT: 8080

jobs:
  test:
    uses: ./.github/workflows/test.yml

  release-candidate:
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/main'
    permissions:
      contents: read
      packages: write

    steps:
    - name: Generate GitHub App Token
      id: app-token
      uses: actions/create-github-app-token@v2
      with:
        app-id: ${{ secrets.APP_ID }}
        private-key: ${{ secrets.APP_PRIVATE_KEY }}

    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ steps.app-token.outputs.token }}

    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Get branch name
      id: branch
      run: |
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
        echo "Branch: ${BRANCH_NAME}"

    - name: Calculate RC version
      id: version
      run: |
        # Get the latest production tag (exclude RC tags) or default to 0.0.0
        CURRENT_VERSION=$(git tag -l 'v*' | grep -v 'rc' | sort -V | tail -1 | sed 's/^v//' 2>/dev/null || echo "0.0.0")
        echo "Current production version: $CURRENT_VERSION"

        # Ensure we have a valid version format
        if [ -z "$CURRENT_VERSION" ] || [ "$CURRENT_VERSION" = "" ]; then
          CURRENT_VERSION="0.0.0"
        fi

        # Parse current version - handle case where version might be empty or malformed
        if [[ "$CURRENT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
        else
          echo "Invalid version format, defaulting to 0.0.0"
          MAJOR=0
          MINOR=0
          PATCH=0
        fi

        # Ensure all version parts are numbers
        MAJOR=${MAJOR:-0}
        MINOR=${MINOR:-0}
        PATCH=${PATCH:-0}

        # Increment patch for RC
        PATCH=$((PATCH + 1))

        # Create RC version with git short SHA
        SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
        RC_VERSION="${MAJOR}.${MINOR}.${PATCH}-rc.${SHORT_SHA}"

        echo "next_version=v${RC_VERSION}" >> $GITHUB_OUTPUT
        echo "version_number=${RC_VERSION}" >> $GITHUB_OUTPUT
        echo "✅ RC version: v${RC_VERSION}"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Create RC tag
      run: |
        # Verify Git configuration
        echo "Git user.name: $(git config user.name)"
        echo "Git user.email: $(git config user.email)"

        VERSION=${{ steps.version.outputs.next_version }}
        git tag -a "$VERSION" -m "Release candidate $VERSION from branch ${{ steps.branch.outputs.branch_name }}"
        git push origin "$VERSION"
        echo "Created RC tag: $VERSION"

    - name: Build and push multi-arch Docker images for RC
      run: |
        VERSION=${{ steps.version.outputs.version_number }}
        REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')

        # Remove any existing builder and create a clean one
        docker buildx rm multiarch-builder 2>/dev/null || true
        docker buildx create --use --name multiarch-builder --driver docker-container
        docker buildx inspect --bootstrap

        # Build and push versioned RC image with clean manifest
        docker buildx build \
          --platform linux/amd64,linux/arm64 \
          --tag ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:${VERSION} \
          --push \
          --provenance=false \
          --sbom=false \
          .

        # Build and push latest-rc image with clean manifest
        docker buildx build \
          --platform linux/amd64,linux/arm64 \
          --tag ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:latest-rc \
          --push \
          --provenance=false \
          --sbom=false \
          .

        echo "Built and pushed clean multi-arch RC Docker images:"
        echo "  - ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:${VERSION} (amd64, arm64)"
        echo "  - ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:latest-rc (amd64, arm64)"

        # Verify manifests
        echo "Verifying manifests:"
        docker buildx imagetools inspect ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:${VERSION}
        docker buildx imagetools inspect ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:latest-rc

    - name: Create RC GitHub release
      env:
        GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
      run: |
        VERSION=${{ steps.version.outputs.next_version }}
        REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
        gh release create "$VERSION" \
          --title "Release Candidate $VERSION" \
          --notes "🚀 Release candidate $VERSION from branch \`${{ steps.branch.outputs.branch_name }}\`

        **This is a pre-release for testing purposes.**

        **Docker Images:**
        - \`ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version_number }}\`
        - \`ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:latest-rc\`

        **Branch:** ${{ steps.branch.outputs.branch_name }}
        **Commit:** ${{ github.sha }}

        **Recent changes:**
        $(git log --oneline -10)" \
          --prerelease

  production-release:
    runs-on: ubuntu-latest
    needs: test
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true && !contains(github.event.pull_request.title, 'skip ci')) ||
      (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main')
    permissions:
      contents: read
      packages: write

    steps:
    - name: Generate GitHub App Token
      id: app-token
      uses: actions/create-github-app-token@v2
      with:
        app-id: ${{ secrets.APP_ID }}
        private-key: ${{ secrets.APP_PRIVATE_KEY }}

    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ steps.app-token.outputs.token }}

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install semantic-release
      run: |
        npm install -g semantic-release @semantic-release/changelog @semantic-release/git @semantic-release/github

    - name: Configure Git
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

    - name: Analyze merged PRs for version bumps
      id: pr-analysis
      env:
        GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
      run: |
        # Get the last release tag
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

        if [ -z "$LAST_TAG" ]; then
          echo "No previous tags found, analyzing all commits"
          COMMIT_RANGE="HEAD"
        else
          echo "Last tag: $LAST_TAG"
          COMMIT_RANGE="${LAST_TAG}..HEAD"
        fi

        # Get merge commits since last release
        MERGE_COMMITS=$(git log $COMMIT_RANGE --merges --pretty=format:"%H %s" | grep "Merge pull request" || echo "")

        echo "🔍 Analyzing merged PRs since last release..."
        if [ -z "$MERGE_COMMITS" ]; then
          echo "No merge commits found in range $COMMIT_RANGE"
        else
          echo "$MERGE_COMMITS"
        fi

        # Initialize version bump analysis
        HAS_MAJOR=false
        HAS_MINOR=false
        HAS_PATCH=false
        HAS_CHANGES=false

        # Analyze each merge commit (only if we have merge commits)
        if [ -n "$MERGE_COMMITS" ]; then
          while IFS= read -r line; do
            if [ -n "$line" ]; then
              HAS_CHANGES=true
              COMMIT_HASH=$(echo "$line" | cut -d' ' -f1)
              PR_NUMBER=$(echo "$line" | grep -oE '#[0-9]+' | sed 's/#//' || echo "")

              if [ -n "$PR_NUMBER" ]; then
                echo "Analyzing PR #$PR_NUMBER (commit: $COMMIT_HASH)"

                # Get PR labels using GitHub API (with error handling)
                PR_LABELS=$(gh pr view $PR_NUMBER --json labels --jq '.labels[].name' 2>/dev/null || echo "")
                echo "PR #$PR_NUMBER labels: $PR_LABELS"

                # Check for version bump indicators in labels
                if echo "$PR_LABELS" | grep -qE "^(breaking-change|major)$"; then
                  echo "  → Major version bump detected (breaking change)"
                  HAS_MAJOR=true
                elif echo "$PR_LABELS" | grep -qE "^(feature|minor)$"; then
                  echo "  → Minor version bump detected (feature)"
                  HAS_MINOR=true
                elif echo "$PR_LABELS" | grep -qE "^(bugfix|fix|patch)$"; then
                  echo "  → Patch version bump detected (fix)"
                  HAS_PATCH=true
                elif echo "$PR_LABELS" | grep -qE "^(no-release|skip-release)$"; then
                  echo "  → No release (skip-release label)"
                else
                  # Fallback: check PR title for conventional commit format
                  PR_TITLE=$(gh pr view $PR_NUMBER --json title --jq '.title' 2>/dev/null || echo "")
                  echo "  PR title: $PR_TITLE"

                  if echo "$PR_TITLE" | grep -qE "^feat(\(.+\))?!:|BREAKING CHANGE"; then
                    echo "  → Major version bump detected (breaking change in title)"
                    HAS_MAJOR=true
                  elif echo "$PR_TITLE" | grep -qE "^feat(\(.+\))?:"; then
                    echo "  → Minor version bump detected (feature in title)"
                    HAS_MINOR=true
                  elif echo "$PR_TITLE" | grep -qE "^(fix|perf|refactor)(\(.+\))?:"; then
                    echo "  → Patch version bump detected (fix in title)"
                    HAS_PATCH=true
                  elif echo "$PR_TITLE" | grep -qE "^(docs|style|test|build|ci|chore)(\(.+\))?:"; then
                    echo "  → No version bump (docs/chore in title)"
                  else
                    echo "  → Default to patch version bump"
                    HAS_PATCH=true
                  fi
                fi
              else
                echo "  → No PR number found in commit message"
                HAS_PATCH=true  # Default to patch for non-PR commits
              fi
            fi
          done <<< "$MERGE_COMMITS"
        else
          echo "No merge commits to analyze, checking for direct commits..."
          # Check if there are any commits since last tag
          COMMIT_COUNT=$(git rev-list $COMMIT_RANGE --count 2>/dev/null || echo "0")
          if [ "$COMMIT_COUNT" -gt 0 ]; then
            echo "Found $COMMIT_COUNT commits since last release, defaulting to patch version"
            HAS_CHANGES=true
            HAS_PATCH=true
          fi
        fi

        # Determine version bump type (highest priority wins)
        if [ "$HAS_MAJOR" = true ]; then
          VERSION_BUMP="major"
        elif [ "$HAS_MINOR" = true ]; then
          VERSION_BUMP="minor"
        elif [ "$HAS_PATCH" = true ]; then
          VERSION_BUMP="patch"
        else
          VERSION_BUMP="none"
        fi

        echo "pr_version_bump=${VERSION_BUMP}" >> $GITHUB_OUTPUT
        echo "has_changes=${HAS_CHANGES}" >> $GITHUB_OUTPUT

        echo ""
        echo "📊 PR Analysis Summary:"
        echo "  Has changes: $HAS_CHANGES"
        echo "  Version bump: $VERSION_BUMP"
        echo "  Major changes: $HAS_MAJOR"
        echo "  Minor changes: $HAS_MINOR"
        echo "  Patch changes: $HAS_PATCH"

    - name: Run semantic-release with PR fallback
      env:
        GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
      run: |
        # First try semantic-release normally
        echo "🚀 Running semantic-release (conventional commits)..."
        npx semantic-release --dry-run > semantic-release-output.txt 2>&1 || true
        cat semantic-release-output.txt

        # Check if semantic-release found a version
        if grep -q "The next release version is" semantic-release-output.txt; then
          echo "✅ Semantic-release detected version bump from conventional commits"
          SEMANTIC_VERSION=$(grep "The next release version is" semantic-release-output.txt | sed 's/.*The next release version is \([0-9.]*\).*/\1/')
          echo "semantic_version=${SEMANTIC_VERSION}" >> $GITHUB_OUTPUT
          echo "use_semantic=true" >> $GITHUB_OUTPUT
        else
          echo "⚠️ No version detected by semantic-release, using PR analysis fallback"
          echo "use_semantic=false" >> $GITHUB_OUTPUT
        fi

    - name: Calculate fallback version
      id: version
      run: |
        USE_SEMANTIC="${{ env.use_semantic }}"
        PR_VERSION_BUMP="${{ steps.pr-analysis.outputs.pr_version_bump }}"
        HAS_CHANGES="${{ steps.pr-analysis.outputs.has_changes }}"
        FORCE_RELEASE="${{ github.event.inputs.force_release }}"
        MANUAL_RELEASE_TYPE="${{ github.event.inputs.release_type }}"

        echo "🔧 Version Calculation Inputs:"
        echo "  Use semantic: $USE_SEMANTIC"
        echo "  PR version bump: $PR_VERSION_BUMP"
        echo "  Has changes: $HAS_CHANGES"
        echo "  Force release: $FORCE_RELEASE"
        echo "  Manual release type: $MANUAL_RELEASE_TYPE"

        if [ "$USE_SEMANTIC" = "true" ]; then
          # Use semantic-release version
          NEXT_VERSION="${{ env.semantic_version }}"
          echo "next_version=v${NEXT_VERSION}" >> $GITHUB_OUTPUT
          echo "version_number=${NEXT_VERSION}" >> $GITHUB_OUTPUT
          echo "has_release=true" >> $GITHUB_OUTPUT
          echo "version_source=semantic-release" >> $GITHUB_OUTPUT
          echo "✅ Using semantic-release version: v${NEXT_VERSION}"
        elif [ "$HAS_CHANGES" = "true" ] && [ "$PR_VERSION_BUMP" != "none" ]; then
          # Calculate version using PR analysis
          CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "0.0.0")
          echo "Current version: $CURRENT_VERSION"

          # Ensure we have a valid version format
          if [ -z "$CURRENT_VERSION" ] || [ "$CURRENT_VERSION" = "" ]; then
            CURRENT_VERSION="0.0.0"
          fi

          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Ensure all version parts are numbers
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}

          # Bump version based on PR analysis
          case "$PR_VERSION_BUMP" in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "next_version=v${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "version_number=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "has_release=true" >> $GITHUB_OUTPUT
          echo "version_source=pr-labels" >> $GITHUB_OUTPUT
          echo "✅ Using PR-based version: v${NEW_VERSION} (${PR_VERSION_BUMP} bump)"
        elif [ "$FORCE_RELEASE" = "true" ]; then
          # Force release with manual version type
          CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "0.0.0")
          echo "Current version: $CURRENT_VERSION"

          # Ensure we have a valid version format
          if [ -z "$CURRENT_VERSION" ] || [ "$CURRENT_VERSION" = "" ]; then
            CURRENT_VERSION="0.0.0"
          fi

          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Ensure all version parts are numbers
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}

          # Bump version based on manual input
          case "$MANUAL_RELEASE_TYPE" in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch"|*)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "next_version=v${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "version_number=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "has_release=true" >> $GITHUB_OUTPUT
          echo "version_source=manual-force" >> $GITHUB_OUTPUT
          echo "✅ Force release: v${NEW_VERSION} (${MANUAL_RELEASE_TYPE} bump)"
        else
          echo "has_release=false" >> $GITHUB_OUTPUT
          echo "version_source=none" >> $GITHUB_OUTPUT
          echo "ℹ️ No release will be created (no relevant changes, use force_release=true to override)"
        fi

    - name: Set up Docker Buildx
      if: steps.version.outputs.has_release == 'true'
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      if: steps.version.outputs.has_release == 'true'
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Create production release tag
      if: steps.version.outputs.has_release == 'true'
      run: |
        VERSION=${{ steps.version.outputs.next_version }}
        git tag -a "$VERSION" -m "Release $VERSION"
        git push origin "$VERSION"
        echo "Created production tag: $VERSION"

    - name: Build and push multi-arch Docker images for production
      if: steps.version.outputs.has_release == 'true'
      run: |
        VERSION=${{ steps.version.outputs.version_number }}
        REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')

        # Remove any existing builder and create a clean one
        docker buildx rm multiarch-builder 2>/dev/null || true
        docker buildx create --use --name multiarch-builder --driver docker-container
        docker buildx inspect --bootstrap

        # Build and push versioned production image with clean manifest
        docker buildx build \
          --platform linux/amd64,linux/arm64 \
          --tag ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:${VERSION} \
          --push \
          --provenance=false \
          --sbom=false \
          .

        # Build and push latest image with clean manifest
        docker buildx build \
          --platform linux/amd64,linux/arm64 \
          --tag ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:latest \
          --push \
          --provenance=false \
          --sbom=false \
          .

        echo "Built and pushed clean multi-arch production Docker images:"
        echo "  - ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:${VERSION} (amd64, arm64)"
        echo "  - ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:latest (amd64, arm64)"

        # Verify manifests
        echo "Verifying manifests:"
        docker buildx imagetools inspect ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:${VERSION}
        docker buildx imagetools inspect ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:latest

    - name: Create production GitHub release
      if: steps.version.outputs.has_release == 'true'
      env:
        GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
      run: |
        VERSION=${{ steps.version.outputs.next_version }}
        REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
        gh release create "$VERSION" \
          --title "Release $VERSION" \
          --notes "🚀 Production release $VERSION

        **Docker Images:**
        - \`ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version_number }}\`
        - \`ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:latest\`

        **Pull the images:**
        \`\`\`bash
        docker pull ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version_number }}
        docker pull ghcr.io/${REPO_LOWER}/${{ env.IMAGE_NAME }}:latest
        \`\`\`

        **Changes in this release:**
        $(git log $(git describe --tags --abbrev=0 2>/dev/null || git rev-list --max-parents=0 HEAD)..HEAD --pretty=format:'- %s' --no-merges)"
